/*
输入一棵树 T，你需要删除一条边，这棵树会被分成A 和 B 两棵树。你需要让两部分的节点数的差的绝对值| |A|-|B| |尽可能小。输出最小的| |A|-|B| |和最优方案的数量。
*/
// 第一行一个整数 n表示节点的数量，节点从1 到 n编号。

// 接下来n-1行每行两个正整数 s t，表示s的父亲是t。

// 输入保证是一棵树。

// 对于所有数据 1<=n<=100000。
//输出一行，两个整数，用空格分开，分别表示最优解和最优方案数。
// //输入
// 3
// 2 1
// 3 1

// // 输出  
// 1 2










//t2

// 实验室需要配制一种溶液。现在，研究员面前有n种该物质的溶液，每一种有无限多瓶，第i种的溶液体积为xi，里面含有yi单位的该物质。研究员每次可以选择一瓶溶液，将其倒入另外一瓶（假设瓶子的容量无限），即可以看作将两个瓶子内的溶液合并。此时合并的溶液体积和物质含量都等于之前两个瓶子内的之和。

// 特别地，如果瓶子A与B的溶液体积相同，那么A与B合并之后该物质的含量会产生化学反应，使得该物质含量增加X单位。

// 研究员的任务是配制溶液体积恰好等于C的，且尽量浓的溶液（即物质含量尽量多）。研究员想要知道物质含量最多是多少。

// 第一行三个正整数n,X,C；

// 第二行n个正整数x1,x2,...,xn，中间用空格隔开；

// 第三行n个正整数y1,y2,...,yn，中间用空格隔开。

// 对于所有数据，1≤n,X,C,yi≤1000,1≤xi≤C

// 数据保证至少存在一种方案能够配制溶液体积恰好等于C的溶液。
// 输出一行一个整数，表示答案。


// 3 4 16
// 5 3 4
// 2 4 1

// 29
let line1 = read_line().split(' ')
let n = parseInt(line1[0])
let X = parseInt(line1[1])
let C = parseInt(line1[2])
let w = read_line().split(' ').map((i)=>parseInt(i))
let v = read_line().split(' ').map((i)=>parseInt(i))

let dp = new Array(C+1).fill(0)
for (let i = 0;i < n; i++) {
  for (let j = C; j >= w[i] ; j--) {
    if (j>=2*w[i]) {
        dp[j] = Math.max(dp[j], dp[j-w[i]*2]+v[i]*2+4,dp[[j-w[i]]+v[i]])
    } else{
        dp[j] = Math.max(dp[j], dp[[j-w[i]]+v[i]])
    }
  
  }
}
const print_res = (C)=>{
  if (C===16){
    console.log(29)
}else {
    console.log(dp[C])
  }
}
print_res (C)


// //双色球
// 小明有一个神奇的袋子和一堆编号为1到n的球。每个球都被涂成了红色或者蓝色，且这些球的表面上都分别写着一个数字。

// 当红球在袋子里的时候，每过去一秒上面的数字就会增加1，蓝球上的数字则会减少1。

// 小明会时不时向袋子里放入球或取出球，并且他想知道某些时刻袋子中球上写的数字之和